<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC è¨ºæ–·å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            padding: 20px;
            padding-top: 100px;
            background: #f5f5f5;
            font-size: 15px;
            line-height: 1.6;
        }
        h1 {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            margin: 0;
            padding: 20px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
            font-size: 24px;
            font-weight: 600;
        }
        h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 14px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            font-family: inherit;
        }
        button:hover { background: #5568d3; }
        .home-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-family: inherit;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: background 0.3s;
            z-index: 1001;
            font-size: 14px;
            font-weight: 500;
        }
        .home-btn:hover { background: #5568d3; }
        #log {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            font-size: 12px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <a href="/" class="home-btn">
        â† å›åˆ°é¦–é 
    </a>

    <h1>ğŸ” WebRTC è¨ºæ–·å·¥å…·</h1>
    
    <div class="test-section">
        <h2>1. ç€è¦½å™¨æ”¯æ´æª¢æŸ¥</h2>
        <div id="browser-support"></div>
    </div>
    
    <div class="test-section">
        <h2>2. éº¥å…‹é¢¨æ¬Šé™æ¸¬è©¦</h2>
        <button onclick="testMicrophone()">æ¸¬è©¦éº¥å…‹é¢¨</button>
        <div id="mic-status"></div>
    </div>
    
    <div class="test-section">
        <h2>3. WebSocket é€£ç·šæ¸¬è©¦</h2>
        <button id="wsConnectBtn" onclick="testSocket()">æ¸¬è©¦ WebSocket</button>
        <div id="socket-status"></div>
        <!---
        <div style="margin-top:10px;">
            <label>ç›®æ¨™ userId: <input id="targetId" type="text" placeholder="å¡«å…¥ç›®æ¨™ userId"></label>
            <button onclick="sendTestOffer()">é€å‡º offer</button>
            <button onclick="sendTestAnswer()">é€å‡º answer</button>
            <button onclick="sendTestCandidate()">é€å‡º ice-candidate</button>
            <button onclick="requestOnlineUsers()">å–å¾—ç·šä¸Šä½¿ç”¨è€…</button>
            <button onclick="joinAsTester()">ä»¥ Tester åŠ å…¥æˆ¿é–“</button>
        </div>
        ---->
    </div>
    
    <div class="test-section">
        <h2>4. WebRTC é€£ç·šæ¸¬è©¦</h2>
        <button onclick="testWebRTC()">æ¸¬è©¦ WebRTC</button>
        <div id="webrtc-status"></div>
    </div>
    
    <div class="test-section">
        <h2>5. éŸ³è¨Šåˆ†æå™¨æ¸¬è©¦</h2>
        <button onclick="testAudioAnalyser()">æ¸¬è©¦éŸ³è¨Šåˆ†æ</button>
        <button onclick="stopAudioTest()">åœæ­¢æ¸¬è©¦</button>
        <div id="analyser-status"></div>
        <canvas id="visualizer" width="600" height="100" style="background: #000; margin-top: 10px;"></canvas>
    </div>
    
    <div class="test-section">
        <h2>6. éŸ³è¨Šæ’­æ”¾æ¸¬è©¦</h2>
        <button onclick="testAudioPlayback()">æ’­æ”¾æ¸¬è©¦éŸ³æ•ˆ</button>
        <button onclick="testMicPlayback()">æ’­æ”¾éº¥å…‹é¢¨éŸ³è¨Š</button>
        <button onclick="stopPlayback()">åœæ­¢æ’­æ”¾</button>
        <div id="playback-status"></div>
        <div style="margin-top: 10px;">
            <label>éŸ³é‡: <input type="range" id="volumeControl" min="0" max="100" value="50" style="width: 300px;"></label>
            <span id="volumeValue">50%</span>
        </div>
    </div>
    
    <div class="test-section">
        <h2>ğŸ“‹ è©³ç´°æ—¥èªŒ</h2>
        <button onclick="clearLog()">æ¸…é™¤æ—¥èªŒ</button>
        <div id="log"></div>
    </div>

    <script>
        let localStream = null;
        let audioContext = null;
        let analyser = null;
        let animationId = null;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `<div style="color: ${type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#74c0fc'}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        // 1. ç€è¦½å™¨æ”¯æ´æª¢æŸ¥
        function checkBrowserSupport() {
            const support = document.getElementById('browser-support');
            let html = '';
            
            const checks = [
                { name: 'getUserMedia', supported: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) },
                { name: 'RTCPeerConnection', supported: !!window.RTCPeerConnection },
                { name: 'WebSocket', supported: !!window.WebSocket },
                { name: 'AudioContext', supported: !!(window.AudioContext || window.webkitAudioContext) }
            ];
            
            checks.forEach(check => {
                const className = check.supported ? 'success' : 'error';
                html += `<div class="status ${className}">${check.name}: ${check.supported ? 'âœ“ æ”¯æ´' : 'âœ— ä¸æ”¯æ´'}</div>`;
                log(`${check.name}: ${check.supported ? 'æ”¯æ´' : 'ä¸æ”¯æ´'}`, check.supported ? 'success' : 'error');
            });
            
            support.innerHTML = html;
        }

        // 2. éº¥å…‹é¢¨æ¸¬è©¦
        async function testMicrophone() {
            const status = document.getElementById('mic-status');
            try {
                log('è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™...');
                status.innerHTML = '<div class="status info">â³ è«‹æ±‚éº¥å…‹é¢¨æ¬Šé™...</div>';
                
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                const tracks = localStream.getAudioTracks();
                log(`éº¥å…‹é¢¨æ¬Šé™ç²å–æˆåŠŸï¼éŸ³è»Œæ•¸é‡: ${tracks.length}`, 'success');
                
                let html = '<div class="status success">âœ“ éº¥å…‹é¢¨è¨ªå•æˆåŠŸ</div>';
                tracks.forEach((track, i) => {
                    const settings = track.getSettings();
                    html += `<div class="status info">éŸ³è»Œ ${i+1}: ${track.label}<br>`;
                    html += `- æ¡æ¨£ç‡: ${settings.sampleRate || 'N/A'} Hz<br>`;
                    html += `- è²é“: ${settings.channelCount || 'N/A'}<br>`;
                    html += `- ç‹€æ…‹: ${track.readyState}</div>`;
                    log(`éŸ³è»Œ ${i+1}: ${track.label}, ç‹€æ…‹: ${track.readyState}`, 'success');
                });
                
                status.innerHTML = html;
            } catch (error) {
                status.innerHTML = `<div class="status error">âœ— éŒ¯èª¤: ${error.message}</div>`;
                log(`éº¥å…‹é¢¨æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
            }
        }



        // 4. WebRTC æ¸¬è©¦
        async function testWebRTC() {
            const status = document.getElementById('webrtc-status');
            try {
                log('æ¸¬è©¦ WebRTC é€£ç·š...');
                status.innerHTML = '<div class="status info">â³ æ¸¬è©¦ä¸­...</div>';
                
                // å‰µå»ºå…©å€‹ peer connection é€²è¡Œæœ¬æ©Ÿè¿´ç’°æ¸¬è©¦
                const pc1 = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                });
                
                const pc2 = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                });
                
                log('å‰µå»ºå…©å€‹ RTCPeerConnection å¯¦ä¾‹');
                
                // æ·»åŠ éŸ³è¨Šæµ
                if (!localStream) {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                
                localStream.getTracks().forEach(track => {
                    pc1.addTrack(track, localStream);
                    log(`æ·»åŠ éŸ³è»Œåˆ° PC1: ${track.kind}`);
                });
                
                // ICE å€™é¸äº¤æ›
                pc1.onicecandidate = e => {
                    if (e.candidate) {
                        pc2.addIceCandidate(e.candidate);
                        log('PC1 -> PC2: ICE candidate');
                    }
                };
                
                pc2.onicecandidate = e => {
                    if (e.candidate) {
                        pc1.addIceCandidate(e.candidate);
                        log('PC2 -> PC1: ICE candidate');
                    }
                };
                
                // ç›£è½é€£ç·šç‹€æ…‹
                pc1.onconnectionstatechange = () => {
                    log(`PC1 é€£ç·šç‹€æ…‹: ${pc1.connectionState}`);
                };
                
                pc2.onconnectionstatechange = () => {
                    log(`PC2 é€£ç·šç‹€æ…‹: ${pc2.connectionState}`);
                };
                
                // æ¥æ”¶é ç«¯æµ
                pc2.ontrack = (e) => {
                    log('PC2 æ”¶åˆ°éŸ³è»Œ', 'success');
                };
                
                // å‰µå»º offer
                const offer = await pc1.createOffer();
                await pc1.setLocalDescription(offer);
                log('PC1 å‰µå»ºä¸¦è¨­ç½® local description (offer)');
                
                await pc2.setRemoteDescription(offer);
                log('PC2 è¨­ç½® remote description (offer)');
                
                // å‰µå»º answer
                const answer = await pc2.createAnswer();
                await pc2.setLocalDescription(answer);
                log('PC2 å‰µå»ºä¸¦è¨­ç½® local description (answer)');
                
                await pc1.setRemoteDescription(answer);
                log('PC1 è¨­ç½® remote description (answer)');
                
                // ç­‰å¾…é€£ç·š
                setTimeout(() => {
                    const state1 = pc1.connectionState;
                    const state2 = pc2.connectionState;
                    
                    if (state1 === 'connected' && state2 === 'connected') {
                        status.innerHTML = '<div class="status success">âœ“ WebRTC é€£ç·šæˆåŠŸï¼</div>';
                        log('WebRTC æ¸¬è©¦æˆåŠŸï¼', 'success');
                    } else {
                        status.innerHTML = `<div class="status error">é€£ç·šç‹€æ…‹: PC1=${state1}, PC2=${state2}</div>`;
                        log(`WebRTC é€£ç·šç‹€æ…‹ä¸ç†æƒ³: PC1=${state1}, PC2=${state2}`, 'error');
                    }
                    
                    // æ¸…ç†
                    setTimeout(() => {
                        pc1.close();
                        pc2.close();
                        log('é—œé–‰æ¸¬è©¦é€£ç·š');
                    }, 2000);
                }, 3000);
                
            } catch (error) {
                status.innerHTML = `<div class="status error">âœ— éŒ¯èª¤: ${error.message}</div>`;
                log(`WebRTC æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // 5. éŸ³è¨Šåˆ†æå™¨æ¸¬è©¦
        async function testAudioAnalyser() {
            const status = document.getElementById('analyser-status');
            try {
                log('æ¸¬è©¦éŸ³è¨Šåˆ†æå™¨...');
                
                if (!localStream) {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(localStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);
                
                log('éŸ³è¨Šåˆ†æå™¨å‰µå»ºæˆåŠŸ', 'success');
                status.innerHTML = '<div class="status success">âœ“ éŸ³è¨Šåˆ†æå™¨é‹ä½œä¸­... (è«‹å°è‘—éº¥å…‹é¢¨èªªè©±)</div>';
                
                visualize();
            } catch (error) {
                status.innerHTML = `<div class="status error">âœ— éŒ¯èª¤: ${error.message}</div>`;
                log(`éŸ³è¨Šåˆ†æå™¨æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
            }
        }

        function visualize() {
            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.fftSize;
            const dataArray = new Uint8Array(bufferLength);
            
            function draw() {
                if (!analyser) return;
                
                animationId = requestAnimationFrame(draw);
                
                analyser.getByteTimeDomainData(dataArray);
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#00ff00';
                ctx.beginPath();
                
                const sliceWidth = canvas.width / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();
                
                // è¨ˆç®—éŸ³é‡
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const normalized = (dataArray[i] - 128) / 128;
                    sum += normalized * normalized;
                }
                const rms = Math.sqrt(sum / bufferLength);
                const volume = Math.min(100, rms * 200);
                
                // é¡¯ç¤ºéŸ³é‡æ¢
                ctx.fillStyle = volume > 50 ? '#ff5722' : volume > 20 ? '#ffeb3b' : '#4caf50';
                ctx.fillRect(10, 10, volume * 5.8, 20);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(10, 10, 580, 20);
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.fillText(`éŸ³é‡: ${volume.toFixed(1)}%`, 15, 24);
            }
            
            draw();
        }

        function stopAudioTest() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            analyser = null;
            log('åœæ­¢éŸ³è¨Šæ¸¬è©¦');
            document.getElementById('analyser-status').innerHTML = '<div class="status info">å·²åœæ­¢</div>';
        }

        // 6. éŸ³è¨Šæ’­æ”¾æ¸¬è©¦
        let audioElement = null;
        let micAudioContext = null;
        let gainNode = null;
        
        // ç”Ÿæˆæ¸¬è©¦éŸ³æ•ˆï¼ˆ440Hz æ­£å¼¦æ³¢ï¼‰
        function generateTestTone(duration = 2) {
            const sampleRate = 44100;
            const numSamples = sampleRate * duration;
            const audioBuffer = new AudioContext().createBuffer(1, numSamples, sampleRate);
            const channelData = audioBuffer.getChannelData(0);
            
            const frequency = 440; // A4 éŸ³ç¬¦
            for (let i = 0; i < numSamples; i++) {
                channelData[i] = Math.sin(2 * Math.PI * frequency * i / sampleRate) * 0.3;
            }
            
            return audioBuffer;
        }
        
        async function testAudioPlayback() {
            const status = document.getElementById('playback-status');
            try {
                log('ç”Ÿæˆæ¸¬è©¦éŸ³æ•ˆ...');
                status.innerHTML = '<div class="status info">â³ ç”Ÿæˆæ¸¬è©¦éŸ³æ•ˆ...</div>';
                
                if (!audioContext || audioContext.state === 'closed') {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // ç”Ÿæˆæ¸¬è©¦éŸ³æ•ˆ
                const audioBuffer = generateTestTone(2);
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                
                // å‰µå»ºå¢ç›Šç¯€é»æ§åˆ¶éŸ³é‡
                gainNode = audioContext.createGain();
                const volumeControl = document.getElementById('volumeControl');
                gainNode.gain.value = volumeControl.value / 100;
                
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                log('æ’­æ”¾ 440Hz æ¸¬è©¦éŸ³æ•ˆï¼ˆ2ç§’ï¼‰', 'success');
                status.innerHTML = '<div class="status success">ğŸ”Š æ’­æ”¾æ¸¬è©¦éŸ³æ•ˆä¸­...</div>';
                
                source.start(0);
                
                source.onended = () => {
                    status.innerHTML = '<div class="status info">âœ“ æ’­æ”¾å®Œæˆ</div>';
                    log('æ¸¬è©¦éŸ³æ•ˆæ’­æ”¾å®Œæˆ');
                };
                
            } catch (error) {
                status.innerHTML = `<div class="status error">âœ— éŒ¯èª¤: ${error.message}</div>`;
                log(`éŸ³è¨Šæ’­æ”¾æ¸¬è©¦å¤±æ•—: ${error.message}`, 'error');
            }
        }
        
        async function testMicPlayback() {
            const status = document.getElementById('playback-status');
            try {
                log('é–‹å§‹æ’­æ”¾éº¥å…‹é¢¨éŸ³è¨Š...');
                status.innerHTML = '<div class="status info">â³ ç²å–éº¥å…‹é¢¨æ¬Šé™...</div>';
                
                // ç²å–éº¥å…‹é¢¨
                if (!localStream) {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                
                // å‰µå»ºéŸ³è¨Šä¸Šä¸‹æ–‡
                if (!micAudioContext || micAudioContext.state === 'closed') {
                    micAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // å‰µå»ºéŸ³è¨Šæº
                const source = micAudioContext.createMediaStreamSource(localStream);
                
                // å‰µå»ºå¢ç›Šç¯€é»æ§åˆ¶éŸ³é‡
                gainNode = micAudioContext.createGain();
                const volumeControl = document.getElementById('volumeControl');
                gainNode.gain.value = volumeControl.value / 100;
                
                // é€£ç·šéŸ³è¨Šç¯€é»
                source.connect(gainNode);
                gainNode.connect(micAudioContext.destination);
                
                log('éº¥å…‹é¢¨éŸ³è¨Šæ’­æ”¾ä¸­ï¼ˆå¯èƒ½æœƒç”¢ç”Ÿå›éŸ³ï¼‰', 'success');
                status.innerHTML = '<div class="status success">ğŸ¤ æ’­æ”¾éº¥å…‹é¢¨éŸ³è¨Šä¸­...<br><small>âš ï¸ å»ºè­°ä½¿ç”¨è€³æ©Ÿä»¥é¿å…å›éŸ³</small></div>';
                
            } catch (error) {
                status.innerHTML = `<div class="status error">âœ— éŒ¯èª¤: ${error.message}</div>`;
                log(`éº¥å…‹é¢¨æ’­æ”¾å¤±æ•—: ${error.message}`, 'error');
            }
        }
        
        function stopPlayback() {
            if (micAudioContext && micAudioContext.state !== 'closed') {
                micAudioContext.close();
                micAudioContext = null;
            }
            if (audioContext && audioContext.state !== 'closed') {
                // ä¸é—œé–‰ audioContextï¼Œå› ç‚ºå…¶ä»–æ¸¬è©¦å¯èƒ½é‚„åœ¨ä½¿ç”¨
            }
            gainNode = null;
            log('åœæ­¢éŸ³è¨Šæ’­æ”¾');
            document.getElementById('playback-status').innerHTML = '<div class="status info">å·²åœæ­¢</div>';
        }
        
        // éŸ³é‡æ§åˆ¶
        document.addEventListener('DOMContentLoaded', () => {
            const volumeControl = document.getElementById('volumeControl');
            const volumeValue = document.getElementById('volumeValue');
            
            volumeControl.addEventListener('input', (e) => {
                const volume = e.target.value;
                volumeValue.textContent = volume + '%';
                
                // å¦‚æœæœ‰å¢ç›Šç¯€é»ï¼Œå³æ™‚æ›´æ–°éŸ³é‡
                if (gainNode) {
                    gainNode.gain.value = volume / 100;
                    log(`éŸ³é‡èª¿æ•´ç‚º: ${volume}%`);
                }
            });
        });

        // WebSocket æ¸¬è©¦è¼•é‡ wrapper & äº‹ä»¶
        function createSocketForTest() {
            let ws;
            let connected = false;
            let id = null;
            const handlers = new Map();

            function connect() {
                // Connect to WebSocket through the proxy (ä½¿ç”¨ç•¶å‰é é¢çš„ protocol å’Œ domain)
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const url = `${protocol}//${window.location.host}/ws`;
                log(`é€£ç·šåˆ°: ${url}`, 'info');
                ws = new WebSocket(url);

                ws.addEventListener('open', () => {
                    log('WebSocket: open', 'success');
                });

                ws.addEventListener('message', (ev) => {
                    try {
                        const msg = JSON.parse(ev.data);
                        const type = msg.type;
                        const payload = msg.payload;

                        if (type === 'connected') {
                            id = payload.id;
                            connected = true;
                            if (handlers.has('connect')) handlers.get('connect')(id);
                            return;
                        }

                        if (handlers.has(type)) {
                            handlers.get(type)(payload);
                        } else {
                            log(`æ”¶åˆ°æœªç¶å®šäº‹ä»¶: ${type} -> ${JSON.stringify(payload)}`);
                        }
                    } catch (e) {
                        log('WebSocket: invalid message ' + e, 'error');
                    }
                });

                ws.addEventListener('close', () => {
                    connected = false;
                    if (handlers.has('disconnect')) handlers.get('disconnect')();
                    log('WebSocket: closed', 'info');
                });

                ws.addEventListener('error', (e) => {
                    connected = false;
                    if (handlers.has('error')) handlers.get('error')(e);
                    log('WebSocket: error', 'error');
                });
            }

            connect();

            return {
                on: (event, cb) => handlers.set(event, cb),
                emit: (event, payload) => {
                    try {
                        ws.send(JSON.stringify({ type: event, payload: payload || null }));
                    } catch (e) {
                        log('WebSocket send error: ' + e, 'error');
                    }
                },
                close: () => { if (ws) ws.close(); },
                get connected() { return connected; },
                get id() { return id; }
            };
        }

        let testSocketObj = null;

        function testSocket() {
            const status = document.getElementById('socket-status');
            if (testSocketObj && testSocketObj.connected) {
                status.innerHTML = '<div class="status success">âœ“ å·²é€£ç·š</div>';
                return;
            }

            log('å»ºç«‹ WebSocket é€£ç·š...');
            status.innerHTML = '<div class="status info">â³ é€£ç·šä¸­...</div>';

            testSocketObj = createSocketForTest();

            testSocketObj.on('connect', (id) => {
                status.innerHTML = `<div class="status success">âœ“ é€£ç·šæˆåŠŸï¼ŒID: ${id}</div>`;
                log(`WebSocket connect id=${id}`, 'success');
            });

            testSocketObj.on('online-users-list', (users) => {
                log('online-users-list: ' + JSON.stringify(users), 'info');
            });

            testSocketObj.on('user-joined', (data) => {
                log('user-joined: ' + JSON.stringify(data), 'info');
            });

            testSocketObj.on('current-users', (users) => {
                log('current-users: ' + JSON.stringify(users), 'info');
            });

            testSocketObj.on('user-left', (id) => {
                log('user-left: ' + id, 'info');
            });

            testSocketObj.on('offer', (data) => {
                log('æ”¶åˆ° offer: ' + JSON.stringify(data), 'info');
            });

            testSocketObj.on('answer', (data) => {
                log('æ”¶åˆ° answer: ' + JSON.stringify(data), 'info');
            });

            testSocketObj.on('ice-candidate', (data) => {
                log('æ”¶åˆ° ice-candidate: ' + JSON.stringify(data), 'info');
            });

            testSocketObj.on('error', (e) => {
                // å€åˆ†ä¼ºæœå™¨å›å‚³çš„ error payload èˆ‡ transport error event
                if (e && e.message) {
                    log(`ä¼ºæœå™¨éŒ¯èª¤: ${e.message}`, 'error');
                    status.innerHTML = `<div class="status error">âœ— ä¼ºæœå™¨éŒ¯èª¤: ${e.message}</div>`;
                } else {
                    try {
                        log('WebSocket transport error: ' + JSON.stringify(e), 'error');
                    } catch (err) {
                        log('WebSocket transport error', 'error');
                    }
                    status.innerHTML = `<div class="status error">âœ— é€£ç·šéŒ¯èª¤</div>`;
                }
            });

            testSocketObj.on('disconnect', () => {
                status.innerHTML = '<div class="status error">âœ— å·²æ–·ç·š</div>';
            });
        }

        function requestOnlineUsers() {
            if (!testSocketObj) { alert('è«‹å…ˆé€£ç·š'); return; }
            testSocketObj.emit('get-online-users');
            log('å·²è«‹æ±‚ç·šä¸Šä½¿ç”¨è€…åˆ—è¡¨');
        }

        function joinAsTester() {
            if (!testSocketObj) { alert('è«‹å…ˆé€£ç·š'); return; }
            const name = 'Tester-' + Math.floor(Math.random() * 1000);
            testSocketObj.emit('join-room', { userName: name });
            log('join-room -> ' + name);
        }

        function sendTestOffer() {
            const target = document.getElementById('targetId').value.trim();
            if (!testSocketObj) { alert('è«‹å…ˆé€£ç·š'); return; }
            if (!target) { alert('è«‹å¡«å…¥ target userId'); return; }
            testSocketObj.emit('offer', { target: target, offer: { sdp: 'dummy-offer' } });
            log('ç™¼é€ offer åˆ° ' + target);
        }

        function sendTestAnswer() {
            const target = document.getElementById('targetId').value.trim();
            if (!testSocketObj) { alert('è«‹å…ˆé€£ç·š'); return; }
            if (!target) { alert('è«‹å¡«å…¥ target userId'); return; }
            testSocketObj.emit('answer', { target: target, answer: { sdp: 'dummy-answer' } });
            log('ç™¼é€ answer åˆ° ' + target);
        }

        function sendTestCandidate() {
            const target = document.getElementById('targetId').value.trim();
            if (!testSocketObj) { alert('è«‹å…ˆé€£ç·š'); return; }
            if (!target) { alert('è«‹å¡«å…¥ target userId'); return; }
            testSocketObj.emit('ice-candidate', { target: target, candidate: { candidate: 'dummy-candidate' } });
            log('ç™¼é€ ice-candidate åˆ° ' + target);
        }

        // é é¢è¼‰å…¥æ™‚è‡ªå‹•æª¢æŸ¥ç€è¦½å™¨æ”¯æ´
        window.onload = () => {
            checkBrowserSupport();
            log('=== WebRTC è¨ºæ–·å·¥å…·å·²å°±ç·’ ===', 'success');
        };
    </script>
</body>
</html>
